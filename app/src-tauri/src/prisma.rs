// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR: &'static str =
	include_str!("/Users/a/projects/apps/otoko/prisma/schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR: &::prisma_client_rust::migrations::include_dir::Dir = &::prisma_client_rust::migrations::include_dir::include_dir!(
	"/Users/a/projects/apps/otoko/prisma/migrations"
);
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder()
		.with_url(url.to_string())
		.build()
		.await
}
pub mod topic {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod title {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TitleEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Title(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTitle(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Title(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Title(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
	}
	pub mod description {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::DescriptionEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Description(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetDescription(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Description(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("description").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Description(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("description").build()
			}
		}
	}
	pub mod categories {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<category::WhereParam>) -> WhereParam {
			WhereParam::CategoriesSome(value)
		}
		pub fn every(value: Vec<category::WhereParam>) -> WhereParam {
			WhereParam::CategoriesEvery(value)
		}
		pub fn none(value: Vec<category::WhereParam>) -> WhereParam {
			WhereParam::CategoriesNone(value)
		}
		pub struct Fetch(pub category::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<category::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: category::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: category::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Categories(fetch.0)
			}
		}
		pub fn fetch(params: Vec<category::WhereParam>) -> Fetch {
			Fetch(category::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<category::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<category::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectCategories(params)
		}
		pub fn set(params: Vec<category::UniqueWhereParam>) -> SetParam {
			SetParam::SetCategories(params)
		}
		pub struct Connect(pub Vec<category::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectCategories(value.0)
			}
		}
		pub enum Include {
			Select(category::ManyArgs, Vec<category::SelectParam>),
			Include(category::ManyArgs, Vec<category::IncludeParam>),
			Fetch(category::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Categories(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("categories");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: category::ManyArgs,
				nested_selections: Vec<category::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: category::ManyArgs,
				nested_selections: Vec<category::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(category::ManyArgs, Vec<category::SelectParam>),
			Include(category::ManyArgs, Vec<category::IncludeParam>),
			Fetch(category::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Categories(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("categories");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: category::ManyArgs,
				nested_selections: Vec<category::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: category::ManyArgs,
				nested_selections: Vec<category::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod url {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UrlEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Url(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUrl(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Url(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Url(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
	}
	pub mod source {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<source::WhereParam>) -> WhereParam {
			WhereParam::SourceIs(value)
		}
		pub fn is_not(value: Vec<source::WhereParam>) -> WhereParam {
			WhereParam::SourceIsNot(value)
		}
		pub struct Fetch(pub source::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<source::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Source(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(source::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: source::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(source::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectSource(value.0)
			}
		}
		pub enum Include {
			Select(Vec<source::SelectParam>),
			Include(Vec<source::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Source(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("source");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<source::SelectParam>),
			Include(Vec<source::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Source(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("source");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod issue {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<issue::WhereParam>) -> WhereParam {
			WhereParam::IssueSome(value)
		}
		pub fn every(value: Vec<issue::WhereParam>) -> WhereParam {
			WhereParam::IssueEvery(value)
		}
		pub fn none(value: Vec<issue::WhereParam>) -> WhereParam {
			WhereParam::IssueNone(value)
		}
		pub struct Fetch(pub issue::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<issue::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: issue::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: issue::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Issue(fetch.0)
			}
		}
		pub fn fetch(params: Vec<issue::WhereParam>) -> Fetch {
			Fetch(issue::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<issue::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<issue::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectIssue(params)
		}
		pub fn set(params: Vec<issue::UniqueWhereParam>) -> SetParam {
			SetParam::SetIssue(params)
		}
		pub struct Connect(pub Vec<issue::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectIssue(value.0)
			}
		}
		pub enum Include {
			Select(issue::ManyArgs, Vec<issue::SelectParam>),
			Include(issue::ManyArgs, Vec<issue::IncludeParam>),
			Fetch(issue::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Issue(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("Issue");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: issue::ManyArgs,
				nested_selections: Vec<issue::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: issue::ManyArgs,
				nested_selections: Vec<issue::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(issue::ManyArgs, Vec<issue::SelectParam>),
			Include(issue::ManyArgs, Vec<issue::IncludeParam>),
			Fetch(issue::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Issue(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("Issue");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: issue::ManyArgs,
				nested_selections: Vec<issue::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: issue::ManyArgs,
				nested_selections: Vec<issue::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod source_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::SourceIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::SourceId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementSourceId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementSourceId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplySourceId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideSourceId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSourceId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SourceId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sourceId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SourceId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sourceId").build()
			}
		}
	}
	pub mod cover {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::CoverEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Cover(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Cover(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetCover(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Cover(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("cover").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Cover(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("cover").build()
			}
		}
	}
	pub fn create(
		title: String,
		description: String,
		url: String,
		source: super::source::UniqueWhereParam,
		cover: String,
		_params: Vec<SetParam>,
	) -> (
		String,
		String,
		String,
		super::source::UniqueWhereParam,
		String,
		Vec<SetParam>,
	) {
		(title, description, url, source, cover, _params)
	}
	pub fn create_unchecked(
		title: String,
		description: String,
		url: String,
		source_id: i32,
		cover: String,
		_params: Vec<SetParam>,
	) -> (String, String, String, i32, String, Vec<SetParam>) {
		(title, description, url, source_id, cover, _params)
	}
	#[macro_export]
	macro_rules ! _select_topic { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: topic :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: topic :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: topic :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: topic :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: topic :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: topic :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , title , description , categories , url , source , issue , source_id , cover } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: topic :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: topic :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: topic :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: topic :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "description" , "categories" , "url" , "source" , "Issue" , "sourceId" , "cover"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: topic :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: topic :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; description) => { String } ; (@ field_type ; categories : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < categories :: Data > } ; (@ field_type ; categories) => { Vec < crate :: prisma :: category :: Data > } ; (@ field_type ; url) => { String } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < issue :: Data > } ; (@ field_type ; issue) => { Vec < crate :: prisma :: issue :: Data > } ; (@ field_type ; source_id) => { i32 } ; (@ field_type ; cover) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Topic" , available fields are "id, title, description, categories, url, source, issue, source_id, cover")) } ; (@ field_module ; categories : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: category :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: source :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: issue :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: title :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: description :: Select) } ; (@ selection_field_to_selection_param ; categories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: categories :: Select :: $ selection_mode ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: category :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; categories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: categories :: Select :: Fetch ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: url :: Select) } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: source :: Select :: $ selection_mode ($ crate :: prisma :: source :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: source :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: issue :: Select :: $ selection_mode ($ crate :: prisma :: issue :: ManyArgs :: new ($ crate :: prisma :: issue :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: issue :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: issue :: Select :: Fetch ($ crate :: prisma :: issue :: ManyArgs :: new ($ crate :: prisma :: issue :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: source_id :: Select) } ; (@ selection_field_to_selection_param ; cover) => { Into :: < $ crate :: prisma :: topic :: SelectParam > :: into ($ crate :: prisma :: topic :: cover :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: topic :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; categories) => { "categories" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; issue) => { "Issue" } ; (@ field_serde_name ; source_id) => { "sourceId" } ; (@ field_serde_name ; cover) => { "cover" } ; }
	pub use _select_topic as select;
	pub enum SelectParam {
		Id(id::Select),
		Title(title::Select),
		Description(description::Select),
		Categories(categories::Select),
		Url(url::Select),
		Source(source::Select),
		Issue(issue::Select),
		SourceId(source_id::Select),
		Cover(cover::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::Categories(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Source(data) => data.to_selection(),
				Self::Issue(data) => data.to_selection(),
				Self::SourceId(data) => data.to_selection(),
				Self::Cover(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_topic { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: topic :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: topic :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: topic :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: topic :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: topic :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: topic :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { categories , source , issue } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub title : String , pub description : String , pub url : String , pub source_id : i32 , pub cover : String , $ (pub $ field : $ crate :: prisma :: topic :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (title) , stringify ! (description) , stringify ! (url) , stringify ! (source_id) , stringify ! (cover)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; title) , & self . title) ? ; state . serialize_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; description) , & self . description) ? ; state . serialize_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; source_id) , & self . source_id) ? ; state . serialize_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; cover) , & self . cover) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , title , description , url , source_id , cover } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; title) , ", " , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; description) , ", " , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; source_id) , ", " , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; cover) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; title) => Ok (Field :: title) , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; description) => Ok (Field :: description) , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; source_id) => Ok (Field :: source_id) , $ crate :: prisma :: topic :: include ! (@ field_serde_name ; cover) => Ok (Field :: cover) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut title = None ; let mut description = None ; let mut url = None ; let mut source_id = None ; let mut cover = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; title))) ; } title = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; description))) ; } description = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; source_id))) ; } source_id = Some (map . next_value () ?) ; } Field :: cover => { if cover . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; cover))) ; } cover = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; id))) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; title))) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; description))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; url))) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; source_id))) ? ; let cover = cover . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: topic :: include ! (@ field_serde_name ; cover))) ? ; Ok (Data { id , title , description , url , source_id , cover , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "description" , "categories" , "url" , "source" , "Issue" , "sourceId" , "cover"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (title) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (description) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (url) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (source_id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (cover) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: topic :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: topic :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; categories : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < categories :: Data > } ; (@ field_type ; categories) => { Vec < crate :: prisma :: category :: Data > } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < issue :: Data > } ; (@ field_type ; issue) => { Vec < crate :: prisma :: issue :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Topic" , available relations are "categories, source, issue")) } ; (@ field_module ; categories : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: category :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: source :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: issue :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; categories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: topic :: IncludeParam > :: into ($ crate :: prisma :: topic :: categories :: Include :: $ selection_mode ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: category :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; categories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: topic :: IncludeParam > :: into ($ crate :: prisma :: topic :: categories :: Include :: Fetch ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: topic :: IncludeParam > :: into ($ crate :: prisma :: topic :: source :: Include :: $ selection_mode ($ crate :: prisma :: source :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: topic :: IncludeParam > :: into ($ crate :: prisma :: topic :: source :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: topic :: IncludeParam > :: into ($ crate :: prisma :: topic :: issue :: Include :: $ selection_mode ($ crate :: prisma :: issue :: ManyArgs :: new ($ crate :: prisma :: issue :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: issue :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: topic :: IncludeParam > :: into ($ crate :: prisma :: topic :: issue :: Include :: Fetch ($ crate :: prisma :: issue :: ManyArgs :: new ($ crate :: prisma :: issue :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: topic :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; categories) => { "categories" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; issue) => { "Issue" } ; (@ field_serde_name ; source_id) => { "sourceId" } ; (@ field_serde_name ; cover) => { "cover" } ; }
	pub use _include_topic as include;
	pub enum IncludeParam {
		Id(id::Include),
		Title(title::Include),
		Description(description::Include),
		Categories(categories::Include),
		Url(url::Include),
		Source(source::Include),
		Issue(issue::Include),
		SourceId(source_id::Include),
		Cover(cover::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::Categories(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Source(data) => data.to_selection(),
				Self::Issue(data) => data.to_selection(),
				Self::SourceId(data) => data.to_selection(),
				Self::Cover(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(rename = "Topic", crate = "prisma_client_rust::rspc::internal::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "title")]
		pub title: String,
		#[serde(rename = "description")]
		pub description: String,
		#[serde(rename = "categories")]
		#[specta(skip)]
		pub categories: Option<Vec<super::category::Data>>,
		#[serde(rename = "url")]
		pub url: String,
		#[serde(rename = "source")]
		#[specta(skip)]
		pub source: Option<Box<super::source::Data>>,
		#[serde(rename = "Issue")]
		#[specta(skip)]
		pub issue: Option<Vec<super::issue::Data>>,
		#[serde(rename = "sourceId")]
		pub source_id: i32,
		#[serde(rename = "cover")]
		pub cover: String,
	}
	impl Data {
		pub fn categories(
			&self,
		) -> Result<&Vec<super::category::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.categories
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(categories),
				))
		}
		pub fn source(
			&self,
		) -> Result<&super::source::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.source
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(source),
				))
				.map(|v| v.as_ref())
		}
		pub fn issue(
			&self,
		) -> Result<&Vec<super::issue::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.issue
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(issue),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Categories(super::category::ManyArgs),
		Source(super::source::UniqueArgs),
		Issue(super::issue::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Categories(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("categories");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::Source(args) => {
					let mut selections = < super :: source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("source");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Issue(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("Issue");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetTitle(String),
		SetDescription(String),
		ConnectCategories(Vec<super::category::UniqueWhereParam>),
		DisconnectCategories(Vec<super::category::UniqueWhereParam>),
		SetCategories(Vec<super::category::UniqueWhereParam>),
		SetUrl(String),
		ConnectSource(super::source::UniqueWhereParam),
		ConnectIssue(Vec<super::issue::UniqueWhereParam>),
		DisconnectIssue(Vec<super::issue::UniqueWhereParam>),
		SetIssue(Vec<super::issue::UniqueWhereParam>),
		SetSourceId(i32),
		IncrementSourceId(i32),
		DecrementSourceId(i32),
		MultiplySourceId(i32),
		DivideSourceId(i32),
		SetCover(String),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetTitle(value) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetDescription(value) => (
					"description".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectCategories(where_params) => (
					"categories".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::category::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectCategories(where_params) => (
					"categories".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::category::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetCategories(where_params) => (
					"categories".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::category::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetUrl(value) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectSource(where_param) => (
					"source".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::source::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::ConnectIssue(where_params) => (
					"Issue".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::issue::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectIssue(where_params) => (
					"Issue".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::issue::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetIssue(where_params) => (
					"Issue".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::issue::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplySourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetCover(value) => (
					"cover".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Title(::prisma_client_rust::Direction),
		Description(::prisma_client_rust::Direction),
		Url(::prisma_client_rust::Direction),
		SourceId(::prisma_client_rust::Direction),
		Cover(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Title(direction) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Description(direction) => (
					"description".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Url(direction) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::SourceId(direction) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Cover(direction) => (
					"cover".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		Id(_prisma::read_filters::IntFilter),
		TitleEquals(String),
		Title(_prisma::read_filters::StringFilter),
		DescriptionEquals(String),
		Description(_prisma::read_filters::StringFilter),
		CategoriesSome(Vec<super::category::WhereParam>),
		CategoriesEvery(Vec<super::category::WhereParam>),
		CategoriesNone(Vec<super::category::WhereParam>),
		UrlEquals(String),
		Url(_prisma::read_filters::StringFilter),
		SourceIs(Vec<super::source::WhereParam>),
		SourceIsNot(Vec<super::source::WhereParam>),
		IssueSome(Vec<super::issue::WhereParam>),
		IssueEvery(Vec<super::issue::WhereParam>),
		IssueNone(Vec<super::issue::WhereParam>),
		SourceIdEquals(i32),
		SourceId(_prisma::read_filters::IntFilter),
		CoverEquals(String),
		Cover(_prisma::read_filters::StringFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::TitleEquals(value) => (
					"title",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Title(value) => ("title", value.into()),
				Self::DescriptionEquals(value) => (
					"description",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Description(value) => ("description", value.into()),
				Self::CategoriesSome(where_params) => (
					"categories",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CategoriesEvery(where_params) => (
					"categories",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CategoriesNone(where_params) => (
					"categories",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::UrlEquals(value) => (
					"url",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Url(value) => ("url", value.into()),
				Self::SourceIs(where_params) => (
					"source",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SourceIsNot(where_params) => (
					"source",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IssueSome(where_params) => (
					"Issue",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IssueEvery(where_params) => (
					"Issue",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IssueNone(where_params) => (
					"Issue",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SourceIdEquals(value) => (
					"sourceId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::SourceId(value) => ("sourceId", value.into()),
				Self::CoverEquals(value) => (
					"cover",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Cover(value) => ("cover", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UrlEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UrlEquals(value) => Self::UrlEquals(value),
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Topic";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "title", "description", "url", "sourceId", "cover"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			title: String,
			description: String,
			url: String,
			source: super::source::UniqueWhereParam,
			cover: String,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(title::set(title));
			_params.push(description::set(description));
			_params.push(url::set(url));
			_params.push(source::connect(source));
			_params.push(cover::set(cover));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(String, String, String, i32, String, Vec<SetParam>)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(title, description, url, source_id, cover, mut _params)| {
					_params.push(title::set(title));
					_params.push(description::set(description));
					_params.push(url::set(url));
					_params.push(source_id::set(source_id));
					_params.push(cover::set(cover));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(title, description, url, source, cover, mut _params): (
				String,
				String,
				String,
				super::source::UniqueWhereParam,
				String,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(title::set(title));
			_params.push(description::set(description));
			_params.push(url::set(url));
			_params.push(source::connect(source));
			_params.push(cover::set(cover));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod source {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod title {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TitleEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Title(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTitle(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Title(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Title(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
	}
	pub mod url {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UrlEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Url(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUrl(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Url(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Url(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
	}
	pub mod lang {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::LangEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Lang(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Lang(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetLang(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Lang(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("lang").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Lang(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("lang").build()
			}
		}
	}
	pub mod topic {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicSome(value)
		}
		pub fn every(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicEvery(value)
		}
		pub fn none(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicNone(value)
		}
		pub struct Fetch(pub topic::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<topic::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: topic::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: topic::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Topic(fetch.0)
			}
		}
		pub fn fetch(params: Vec<topic::WhereParam>) -> Fetch {
			Fetch(topic::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<topic::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<topic::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectTopic(params)
		}
		pub fn set(params: Vec<topic::UniqueWhereParam>) -> SetParam {
			SetParam::SetTopic(params)
		}
		pub struct Connect(pub Vec<topic::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectTopic(value.0)
			}
		}
		pub enum Include {
			Select(topic::ManyArgs, Vec<topic::SelectParam>),
			Include(topic::ManyArgs, Vec<topic::IncludeParam>),
			Fetch(topic::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Topic(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("Topic");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(topic::ManyArgs, Vec<topic::SelectParam>),
			Include(topic::ManyArgs, Vec<topic::IncludeParam>),
			Fetch(topic::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Topic(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("Topic");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod category {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<category::WhereParam>) -> WhereParam {
			WhereParam::CategorySome(value)
		}
		pub fn every(value: Vec<category::WhereParam>) -> WhereParam {
			WhereParam::CategoryEvery(value)
		}
		pub fn none(value: Vec<category::WhereParam>) -> WhereParam {
			WhereParam::CategoryNone(value)
		}
		pub struct Fetch(pub category::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<category::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: category::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: category::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Category(fetch.0)
			}
		}
		pub fn fetch(params: Vec<category::WhereParam>) -> Fetch {
			Fetch(category::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<category::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<category::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectCategory(params)
		}
		pub fn set(params: Vec<category::UniqueWhereParam>) -> SetParam {
			SetParam::SetCategory(params)
		}
		pub struct Connect(pub Vec<category::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectCategory(value.0)
			}
		}
		pub enum Include {
			Select(category::ManyArgs, Vec<category::SelectParam>),
			Include(category::ManyArgs, Vec<category::IncludeParam>),
			Fetch(category::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Category(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("Category");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: category::ManyArgs,
				nested_selections: Vec<category::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: category::ManyArgs,
				nested_selections: Vec<category::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(category::ManyArgs, Vec<category::SelectParam>),
			Include(category::ManyArgs, Vec<category::IncludeParam>),
			Fetch(category::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Category(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("Category");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: category::ManyArgs,
				nested_selections: Vec<category::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: category::ManyArgs,
				nested_selections: Vec<category::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub fn create(
		title: String,
		url: String,
		lang: String,
		_params: Vec<SetParam>,
	) -> (String, String, String, Vec<SetParam>) {
		(title, url, lang, _params)
	}
	pub fn create_unchecked(
		title: String,
		url: String,
		lang: String,
		_params: Vec<SetParam>,
	) -> (String, String, String, Vec<SetParam>) {
		(title, url, lang, _params)
	}
	#[macro_export]
	macro_rules ! _select_source { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: source :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: source :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: source :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: source :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , title , url , lang , topic , category } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: source :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: source :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: source :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: source :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: source :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: source :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "url" , "lang" , "Topic" , "Category"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: source :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: source :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; url) => { String } ; (@ field_type ; lang) => { String } ; (@ field_type ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < topic :: Data > } ; (@ field_type ; topic) => { Vec < crate :: prisma :: topic :: Data > } ; (@ field_type ; category : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < category :: Data > } ; (@ field_type ; category) => { Vec < crate :: prisma :: category :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Source" , available fields are "id, title, url, lang, topic, category")) } ; (@ field_module ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: topic :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; category : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: category :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: title :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: url :: Select) } ; (@ selection_field_to_selection_param ; lang) => { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: lang :: Select) } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: topic :: Select :: $ selection_mode ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: topic :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: topic :: Select :: Fetch ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; category $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: category :: Select :: $ selection_mode ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: category :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; category $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: source :: SelectParam > :: into ($ crate :: prisma :: source :: category :: Select :: Fetch ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: source :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; lang) => { "lang" } ; (@ field_serde_name ; topic) => { "Topic" } ; (@ field_serde_name ; category) => { "Category" } ; }
	pub use _select_source as select;
	pub enum SelectParam {
		Id(id::Select),
		Title(title::Select),
		Url(url::Select),
		Lang(lang::Select),
		Topic(topic::Select),
		Category(category::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Lang(data) => data.to_selection(),
				Self::Topic(data) => data.to_selection(),
				Self::Category(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_source { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: source :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: source :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: source :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: source :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { topic , category } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub title : String , pub url : String , pub lang : String , $ (pub $ field : $ crate :: prisma :: source :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (title) , stringify ! (url) , stringify ! (lang)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; title) , & self . title) ? ; state . serialize_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; lang) , & self . lang) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , title , url , lang } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: source :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: source :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: source :: include ! (@ field_serde_name ; title) , ", " , $ crate :: prisma :: source :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: source :: include ! (@ field_serde_name ; lang) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: source :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: source :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: source :: include ! (@ field_serde_name ; title) => Ok (Field :: title) , $ crate :: prisma :: source :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: source :: include ! (@ field_serde_name ; lang) => Ok (Field :: lang) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut title = None ; let mut url = None ; let mut lang = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; title))) ; } title = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: lang => { if lang . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; lang))) ; } lang = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; id))) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; title))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; url))) ? ; let lang = lang . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: source :: include ! (@ field_serde_name ; lang))) ? ; Ok (Data { id , title , url , lang , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "url" , "lang" , "Topic" , "Category"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (title) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (url) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (lang) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: source :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: source :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < topic :: Data > } ; (@ field_type ; topic) => { Vec < crate :: prisma :: topic :: Data > } ; (@ field_type ; category : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < category :: Data > } ; (@ field_type ; category) => { Vec < crate :: prisma :: category :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Source" , available relations are "topic, category")) } ; (@ field_module ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: topic :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; category : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: category :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: source :: IncludeParam > :: into ($ crate :: prisma :: source :: topic :: Include :: $ selection_mode ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: topic :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: source :: IncludeParam > :: into ($ crate :: prisma :: source :: topic :: Include :: Fetch ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; category $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: source :: IncludeParam > :: into ($ crate :: prisma :: source :: category :: Include :: $ selection_mode ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: category :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; category $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: source :: IncludeParam > :: into ($ crate :: prisma :: source :: category :: Include :: Fetch ($ crate :: prisma :: category :: ManyArgs :: new ($ crate :: prisma :: category :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: source :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; lang) => { "lang" } ; (@ field_serde_name ; topic) => { "Topic" } ; (@ field_serde_name ; category) => { "Category" } ; }
	pub use _include_source as include;
	pub enum IncludeParam {
		Id(id::Include),
		Title(title::Include),
		Url(url::Include),
		Lang(lang::Include),
		Topic(topic::Include),
		Category(category::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Lang(data) => data.to_selection(),
				Self::Topic(data) => data.to_selection(),
				Self::Category(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(
		rename = "Source",
		crate = "prisma_client_rust::rspc::internal::specta"
	)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "title")]
		pub title: String,
		#[serde(rename = "url")]
		pub url: String,
		#[serde(rename = "lang")]
		pub lang: String,
		#[serde(rename = "Topic")]
		#[specta(skip)]
		pub topic: Option<Vec<super::topic::Data>>,
		#[serde(rename = "Category")]
		#[specta(skip)]
		pub category: Option<Vec<super::category::Data>>,
	}
	impl Data {
		pub fn topic(
			&self,
		) -> Result<&Vec<super::topic::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.topic
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(topic),
				))
		}
		pub fn category(
			&self,
		) -> Result<&Vec<super::category::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.category
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(category),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Topic(super::topic::ManyArgs),
		Category(super::category::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Topic(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("Topic");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::Category(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("Category");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetTitle(String),
		SetUrl(String),
		SetLang(String),
		ConnectTopic(Vec<super::topic::UniqueWhereParam>),
		DisconnectTopic(Vec<super::topic::UniqueWhereParam>),
		SetTopic(Vec<super::topic::UniqueWhereParam>),
		ConnectCategory(Vec<super::category::UniqueWhereParam>),
		DisconnectCategory(Vec<super::category::UniqueWhereParam>),
		SetCategory(Vec<super::category::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetTitle(value) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetUrl(value) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetLang(value) => (
					"lang".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectTopic(where_params) => (
					"Topic".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::topic::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectTopic(where_params) => (
					"Topic".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::topic::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetTopic(where_params) => (
					"Topic".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::topic::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::ConnectCategory(where_params) => (
					"Category".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::category::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectCategory(where_params) => (
					"Category".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::category::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetCategory(where_params) => (
					"Category".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::category::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Title(::prisma_client_rust::Direction),
		Url(::prisma_client_rust::Direction),
		Lang(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Title(direction) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Url(direction) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Lang(direction) => (
					"lang".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		Id(_prisma::read_filters::IntFilter),
		TitleEquals(String),
		Title(_prisma::read_filters::StringFilter),
		UrlEquals(String),
		Url(_prisma::read_filters::StringFilter),
		LangEquals(String),
		Lang(_prisma::read_filters::StringFilter),
		TopicSome(Vec<super::topic::WhereParam>),
		TopicEvery(Vec<super::topic::WhereParam>),
		TopicNone(Vec<super::topic::WhereParam>),
		CategorySome(Vec<super::category::WhereParam>),
		CategoryEvery(Vec<super::category::WhereParam>),
		CategoryNone(Vec<super::category::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::TitleEquals(value) => (
					"title",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Title(value) => ("title", value.into()),
				Self::UrlEquals(value) => (
					"url",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Url(value) => ("url", value.into()),
				Self::LangEquals(value) => (
					"lang",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Lang(value) => ("lang", value.into()),
				Self::TopicSome(where_params) => (
					"Topic",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TopicEvery(where_params) => (
					"Topic",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TopicNone(where_params) => (
					"Topic",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CategorySome(where_params) => (
					"Category",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CategoryEvery(where_params) => (
					"Category",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CategoryNone(where_params) => (
					"Category",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UrlEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UrlEquals(value) => Self::UrlEquals(value),
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Source";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "title", "url", "lang"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			title: String,
			url: String,
			lang: String,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(title::set(title));
			_params.push(url::set(url));
			_params.push(lang::set(lang));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(String, String, String, Vec<SetParam>)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(title, url, lang, mut _params)| {
					_params.push(title::set(title));
					_params.push(url::set(url));
					_params.push(lang::set(lang));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(title, url, lang, mut _params): (String, String, String, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(title::set(title));
			_params.push(url::set(url));
			_params.push(lang::set(lang));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod issue {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod url {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UrlEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Url(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUrl(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Url(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Url(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
	}
	pub mod title {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TitleEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Title(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTitle(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Title(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Title(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
	}
	pub mod topic {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicIs(value)
		}
		pub fn is_not(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicIsNot(value)
		}
		pub struct Fetch(pub topic::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<topic::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Topic(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(topic::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: topic::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(topic::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectTopic(value.0)
			}
		}
		pub enum Include {
			Select(Vec<topic::SelectParam>),
			Include(Vec<topic::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Topic(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("topic");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<topic::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<topic::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<topic::SelectParam>),
			Include(Vec<topic::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Topic(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("topic");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<topic::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<topic::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod topic_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TopicIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::TopicId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::TopicId(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::TopicId(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::TopicId(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::TopicId(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::TopicId(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::TopicId(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::TopicId(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementTopicId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementTopicId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyTopicId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideTopicId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTopicId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TopicId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("topicId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TopicId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("topicId").build()
			}
		}
	}
	pub mod items {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<issue_item::WhereParam>) -> WhereParam {
			WhereParam::ItemsSome(value)
		}
		pub fn every(value: Vec<issue_item::WhereParam>) -> WhereParam {
			WhereParam::ItemsEvery(value)
		}
		pub fn none(value: Vec<issue_item::WhereParam>) -> WhereParam {
			WhereParam::ItemsNone(value)
		}
		pub struct Fetch(pub issue_item::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<issue_item::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: issue_item::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: issue_item::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Items(fetch.0)
			}
		}
		pub fn fetch(params: Vec<issue_item::WhereParam>) -> Fetch {
			Fetch(issue_item::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<issue_item::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<issue_item::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectItems(params)
		}
		pub fn set(params: Vec<issue_item::UniqueWhereParam>) -> SetParam {
			SetParam::SetItems(params)
		}
		pub struct Connect(pub Vec<issue_item::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectItems(value.0)
			}
		}
		pub enum Include {
			Select(issue_item::ManyArgs, Vec<issue_item::SelectParam>),
			Include(issue_item::ManyArgs, Vec<issue_item::IncludeParam>),
			Fetch(issue_item::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Items(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("items");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < issue_item :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< issue_item :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: issue_item::ManyArgs,
				nested_selections: Vec<issue_item::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: issue_item::ManyArgs,
				nested_selections: Vec<issue_item::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(issue_item::ManyArgs, Vec<issue_item::SelectParam>),
			Include(issue_item::ManyArgs, Vec<issue_item::IncludeParam>),
			Fetch(issue_item::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Items(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("items");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< issue_item :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: issue_item::ManyArgs,
				nested_selections: Vec<issue_item::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: issue_item::ManyArgs,
				nested_selections: Vec<issue_item::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub fn create(
		url: String,
		title: String,
		topic: super::topic::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> (
		String,
		String,
		super::topic::UniqueWhereParam,
		Vec<SetParam>,
	) {
		(url, title, topic, _params)
	}
	pub fn create_unchecked(
		url: String,
		title: String,
		topic_id: i32,
		_params: Vec<SetParam>,
	) -> (String, String, i32, Vec<SetParam>) {
		(url, title, topic_id, _params)
	}
	#[macro_export]
	macro_rules ! _select_issue { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: issue :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: issue :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: issue :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: issue :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: issue :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: issue :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , url , title , topic , topic_id , items } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: issue :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: issue :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: issue :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: issue :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "title" , "topic" , "topicId" , "items"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: issue :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: issue :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; url) => { String } ; (@ field_type ; title) => { String } ; (@ field_type ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { topic :: Data } ; (@ field_type ; topic) => { crate :: prisma :: topic :: Data } ; (@ field_type ; topic_id) => { i32 } ; (@ field_type ; items : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < items :: Data > } ; (@ field_type ; items) => { Vec < crate :: prisma :: issue_item :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Issue" , available fields are "id, url, title, topic, topic_id, items")) } ; (@ field_module ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: topic :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; items : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: issue_item :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: id :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: url :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: title :: Select) } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: topic :: Select :: $ selection_mode ($ crate :: prisma :: topic :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: topic :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; topic_id) => { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: topic_id :: Select) } ; (@ selection_field_to_selection_param ; items $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: items :: Select :: $ selection_mode ($ crate :: prisma :: issue_item :: ManyArgs :: new ($ crate :: prisma :: issue_item :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: issue_item :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; items $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: issue :: SelectParam > :: into ($ crate :: prisma :: issue :: items :: Select :: Fetch ($ crate :: prisma :: issue_item :: ManyArgs :: new ($ crate :: prisma :: issue_item :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: issue :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; topic) => { "topic" } ; (@ field_serde_name ; topic_id) => { "topicId" } ; (@ field_serde_name ; items) => { "items" } ; }
	pub use _select_issue as select;
	pub enum SelectParam {
		Id(id::Select),
		Url(url::Select),
		Title(title::Select),
		Topic(topic::Select),
		TopicId(topic_id::Select),
		Items(items::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Topic(data) => data.to_selection(),
				Self::TopicId(data) => data.to_selection(),
				Self::Items(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_issue { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: issue :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: issue :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: issue :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: issue :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: issue :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: issue :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { topic , items } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub url : String , pub title : String , pub topic_id : i32 , $ (pub $ field : $ crate :: prisma :: issue :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (title) , stringify ! (topic_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; title) , & self . title) ? ; state . serialize_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; topic_id) , & self . topic_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , url , title , topic_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; title) , ", " , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; topic_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; title) => Ok (Field :: title) , $ crate :: prisma :: issue :: include ! (@ field_serde_name ; topic_id) => Ok (Field :: topic_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut url = None ; let mut title = None ; let mut topic_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; title))) ; } title = Some (map . next_value () ?) ; } Field :: topic_id => { if topic_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; topic_id))) ; } topic_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; id))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; url))) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; title))) ? ; let topic_id = topic_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue :: include ! (@ field_serde_name ; topic_id))) ? ; Ok (Data { id , url , title , topic_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "title" , "topic" , "topicId" , "items"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (url) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (title) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (topic_id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: issue :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: issue :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { topic :: Data } ; (@ field_type ; topic) => { crate :: prisma :: topic :: Data } ; (@ field_type ; items : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < items :: Data > } ; (@ field_type ; items) => { Vec < crate :: prisma :: issue_item :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Issue" , available relations are "topic, items")) } ; (@ field_module ; topic : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: topic :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; items : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: issue_item :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: issue :: IncludeParam > :: into ($ crate :: prisma :: issue :: topic :: Include :: $ selection_mode ($ crate :: prisma :: topic :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; topic $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: issue :: IncludeParam > :: into ($ crate :: prisma :: issue :: topic :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; items $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: issue :: IncludeParam > :: into ($ crate :: prisma :: issue :: items :: Include :: $ selection_mode ($ crate :: prisma :: issue_item :: ManyArgs :: new ($ crate :: prisma :: issue_item :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: issue_item :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; items $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: issue :: IncludeParam > :: into ($ crate :: prisma :: issue :: items :: Include :: Fetch ($ crate :: prisma :: issue_item :: ManyArgs :: new ($ crate :: prisma :: issue_item :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: issue :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; topic) => { "topic" } ; (@ field_serde_name ; topic_id) => { "topicId" } ; (@ field_serde_name ; items) => { "items" } ; }
	pub use _include_issue as include;
	pub enum IncludeParam {
		Id(id::Include),
		Url(url::Include),
		Title(title::Include),
		Topic(topic::Include),
		TopicId(topic_id::Include),
		Items(items::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Topic(data) => data.to_selection(),
				Self::TopicId(data) => data.to_selection(),
				Self::Items(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(rename = "Issue", crate = "prisma_client_rust::rspc::internal::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "url")]
		pub url: String,
		#[serde(rename = "title")]
		pub title: String,
		#[serde(rename = "topic")]
		#[specta(skip)]
		pub topic: Option<Box<super::topic::Data>>,
		#[serde(rename = "topicId")]
		pub topic_id: i32,
		#[serde(rename = "items")]
		#[specta(skip)]
		pub items: Option<Vec<super::issue_item::Data>>,
	}
	impl Data {
		pub fn topic(
			&self,
		) -> Result<&super::topic::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.topic
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(topic),
				))
				.map(|v| v.as_ref())
		}
		pub fn items(
			&self,
		) -> Result<&Vec<super::issue_item::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.items
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(items),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Topic(super::topic::UniqueArgs),
		Items(super::issue_item::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Topic(args) => {
					let mut selections = < super :: topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("topic");
					builder.nested_selections(selections);
					builder.build()
				}
				Self::Items(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: issue_item :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("items");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetUrl(String),
		SetTitle(String),
		ConnectTopic(super::topic::UniqueWhereParam),
		SetTopicId(i32),
		IncrementTopicId(i32),
		DecrementTopicId(i32),
		MultiplyTopicId(i32),
		DivideTopicId(i32),
		ConnectItems(Vec<super::issue_item::UniqueWhereParam>),
		DisconnectItems(Vec<super::issue_item::UniqueWhereParam>),
		SetItems(Vec<super::issue_item::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetUrl(value) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetTitle(value) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectTopic(where_param) => (
					"topic".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::topic::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::SetTopicId(value) => (
					"topicId".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementTopicId(value) => (
					"topicId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementTopicId(value) => (
					"topicId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyTopicId(value) => (
					"topicId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideTopicId(value) => (
					"topicId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::ConnectItems(where_params) => (
					"items".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::issue_item::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectItems(where_params) => (
					"items".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::issue_item::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetItems(where_params) => (
					"items".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::issue_item::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Url(::prisma_client_rust::Direction),
		Title(::prisma_client_rust::Direction),
		TopicId(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Url(direction) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Title(direction) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::TopicId(direction) => (
					"topicId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		Id(_prisma::read_filters::IntFilter),
		UrlEquals(String),
		Url(_prisma::read_filters::StringFilter),
		TitleEquals(String),
		Title(_prisma::read_filters::StringFilter),
		TopicIs(Vec<super::topic::WhereParam>),
		TopicIsNot(Vec<super::topic::WhereParam>),
		TopicIdEquals(i32),
		TopicId(_prisma::read_filters::IntFilter),
		ItemsSome(Vec<super::issue_item::WhereParam>),
		ItemsEvery(Vec<super::issue_item::WhereParam>),
		ItemsNone(Vec<super::issue_item::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::UrlEquals(value) => (
					"url",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Url(value) => ("url", value.into()),
				Self::TitleEquals(value) => (
					"title",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Title(value) => ("title", value.into()),
				Self::TopicIs(where_params) => (
					"topic",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TopicIsNot(where_params) => (
					"topic",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TopicIdEquals(value) => (
					"topicId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::TopicId(value) => ("topicId", value.into()),
				Self::ItemsSome(where_params) => (
					"items",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ItemsEvery(where_params) => (
					"items",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ItemsNone(where_params) => (
					"items",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UrlEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UrlEquals(value) => Self::UrlEquals(value),
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Issue";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "url", "title", "topicId"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			url: String,
			title: String,
			topic: super::topic::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(url::set(url));
			_params.push(title::set(title));
			_params.push(topic::connect(topic));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(String, String, i32, Vec<SetParam>)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(url, title, topic_id, mut _params)| {
					_params.push(url::set(url));
					_params.push(title::set(title));
					_params.push(topic_id::set(topic_id));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(url, title, topic, mut _params): (
				String,
				String,
				super::topic::UniqueWhereParam,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(url::set(url));
			_params.push(title::set(title));
			_params.push(topic::connect(topic));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod issue_item {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod url {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UrlEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Url(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUrl(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Url(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Url(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
	}
	pub mod issue {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<issue::WhereParam>) -> WhereParam {
			WhereParam::IssueIs(value)
		}
		pub fn is_not(value: Vec<issue::WhereParam>) -> WhereParam {
			WhereParam::IssueIsNot(value)
		}
		pub struct Fetch(pub issue::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<issue::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Issue(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(issue::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: issue::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(issue::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectIssue(value.0)
			}
		}
		pub enum Include {
			Select(Vec<issue::SelectParam>),
			Include(Vec<issue::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Issue(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("issue");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<issue::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<issue::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<issue::SelectParam>),
			Include(Vec<issue::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Issue(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("issue");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<issue::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<issue::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod issue_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::IssueIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::IssueId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IssueId(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IssueId(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::IssueId(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::IssueId(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::IssueId(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::IssueId(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::IssueId(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementIssueId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementIssueId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyIssueId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideIssueId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetIssueId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IssueId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("issueId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IssueId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("issueId").build()
			}
		}
	}
	pub fn create(
		url: String,
		issue: super::issue::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> (String, super::issue::UniqueWhereParam, Vec<SetParam>) {
		(url, issue, _params)
	}
	pub fn create_unchecked(
		url: String,
		issue_id: i32,
		_params: Vec<SetParam>,
	) -> (String, i32, Vec<SetParam>) {
		(url, issue_id, _params)
	}
	#[macro_export]
	macro_rules ! _select_issue_item { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: issue_item :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: issue_item :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: issue_item :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: issue_item :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: issue_item :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: issue_item :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , url , issue , issue_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: issue_item :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: issue_item :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: issue_item :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: issue_item :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue_item :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue_item :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "issue" , "issueId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: issue_item :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: issue_item :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; url) => { String } ; (@ field_type ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { issue :: Data } ; (@ field_type ; issue) => { crate :: prisma :: issue :: Data } ; (@ field_type ; issue_id) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "IssueItem" , available fields are "id, url, issue, issue_id")) } ; (@ field_module ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: issue :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: issue_item :: SelectParam > :: into ($ crate :: prisma :: issue_item :: id :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: issue_item :: SelectParam > :: into ($ crate :: prisma :: issue_item :: url :: Select) } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: issue_item :: SelectParam > :: into ($ crate :: prisma :: issue_item :: issue :: Select :: $ selection_mode ($ crate :: prisma :: issue :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: issue_item :: SelectParam > :: into ($ crate :: prisma :: issue_item :: issue :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; issue_id) => { Into :: < $ crate :: prisma :: issue_item :: SelectParam > :: into ($ crate :: prisma :: issue_item :: issue_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: issue_item :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; issue) => { "issue" } ; (@ field_serde_name ; issue_id) => { "issueId" } ; }
	pub use _select_issue_item as select;
	pub enum SelectParam {
		Id(id::Select),
		Url(url::Select),
		Issue(issue::Select),
		IssueId(issue_id::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Issue(data) => data.to_selection(),
				Self::IssueId(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_issue_item { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: issue_item :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: issue_item :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: issue_item :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: issue_item :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: issue_item :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: issue_item :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: issue_item :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: issue_item :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { issue } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub url : String , pub issue_id : i32 , $ (pub $ field : $ crate :: prisma :: issue_item :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (issue_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; issue_id) , & self . issue_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , url , issue_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; issue_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; issue_id) => Ok (Field :: issue_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut url = None ; let mut issue_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: issue_id => { if issue_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; issue_id))) ; } issue_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; id))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; url))) ? ; let issue_id = issue_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: issue_item :: include ! (@ field_serde_name ; issue_id))) ? ; Ok (Data { id , url , issue_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "issue" , "issueId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (url) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (issue_id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: issue_item :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: issue_item :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { issue :: Data } ; (@ field_type ; issue) => { crate :: prisma :: issue :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IssueItem" , available relations are "issue")) } ; (@ field_module ; issue : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: issue :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: issue_item :: IncludeParam > :: into ($ crate :: prisma :: issue_item :: issue :: Include :: $ selection_mode ($ crate :: prisma :: issue :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; issue $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: issue_item :: IncludeParam > :: into ($ crate :: prisma :: issue_item :: issue :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: issue_item :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; issue) => { "issue" } ; (@ field_serde_name ; issue_id) => { "issueId" } ; }
	pub use _include_issue_item as include;
	pub enum IncludeParam {
		Id(id::Include),
		Url(url::Include),
		Issue(issue::Include),
		IssueId(issue_id::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Issue(data) => data.to_selection(),
				Self::IssueId(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(
		rename = "IssueItem",
		crate = "prisma_client_rust::rspc::internal::specta"
	)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "url")]
		pub url: String,
		#[serde(rename = "issue")]
		#[specta(skip)]
		pub issue: Option<Box<super::issue::Data>>,
		#[serde(rename = "issueId")]
		pub issue_id: i32,
	}
	impl Data {
		pub fn issue(
			&self,
		) -> Result<&super::issue::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.issue
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(issue),
				))
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Issue(super::issue::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Issue(args) => {
					let mut selections = < super :: issue :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("issue");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetUrl(String),
		ConnectIssue(super::issue::UniqueWhereParam),
		SetIssueId(i32),
		IncrementIssueId(i32),
		DecrementIssueId(i32),
		MultiplyIssueId(i32),
		DivideIssueId(i32),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetUrl(value) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectIssue(where_param) => (
					"issue".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::issue::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::SetIssueId(value) => (
					"issueId".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementIssueId(value) => (
					"issueId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementIssueId(value) => (
					"issueId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyIssueId(value) => (
					"issueId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideIssueId(value) => (
					"issueId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Url(::prisma_client_rust::Direction),
		IssueId(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Url(direction) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::IssueId(direction) => (
					"issueId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		Id(_prisma::read_filters::IntFilter),
		UrlEquals(String),
		Url(_prisma::read_filters::StringFilter),
		IssueIs(Vec<super::issue::WhereParam>),
		IssueIsNot(Vec<super::issue::WhereParam>),
		IssueIdEquals(i32),
		IssueId(_prisma::read_filters::IntFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::UrlEquals(value) => (
					"url",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Url(value) => ("url", value.into()),
				Self::IssueIs(where_params) => (
					"issue",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IssueIsNot(where_params) => (
					"issue",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IssueIdEquals(value) => (
					"issueId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IssueId(value) => ("issueId", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UrlEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UrlEquals(value) => Self::UrlEquals(value),
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "IssueItem";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "url", "issueId"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			url: String,
			issue: super::issue::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(url::set(url));
			_params.push(issue::connect(issue));
			Create::new(self.client, _params)
		}
		pub fn create_many(self, data: Vec<(String, i32, Vec<SetParam>)>) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(url, issue_id, mut _params)| {
					_params.push(url::set(url));
					_params.push(issue_id::set(issue_id));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(url, issue, mut _params): (String, super::issue::UniqueWhereParam, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(url::set(url));
			_params.push(issue::connect(issue));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod category {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod title {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TitleEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Title(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Title(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetTitle(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Title(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Title(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("title").build()
			}
		}
	}
	pub mod topics {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicsSome(value)
		}
		pub fn every(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicsEvery(value)
		}
		pub fn none(value: Vec<topic::WhereParam>) -> WhereParam {
			WhereParam::TopicsNone(value)
		}
		pub struct Fetch(pub topic::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<topic::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: topic::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: topic::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Topics(fetch.0)
			}
		}
		pub fn fetch(params: Vec<topic::WhereParam>) -> Fetch {
			Fetch(topic::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<topic::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<topic::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectTopics(params)
		}
		pub fn set(params: Vec<topic::UniqueWhereParam>) -> SetParam {
			SetParam::SetTopics(params)
		}
		pub struct Connect(pub Vec<topic::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectTopics(value.0)
			}
		}
		pub enum Include {
			Select(topic::ManyArgs, Vec<topic::SelectParam>),
			Include(topic::ManyArgs, Vec<topic::IncludeParam>),
			Fetch(topic::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Topics(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("topics");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(topic::ManyArgs, Vec<topic::SelectParam>),
			Include(topic::ManyArgs, Vec<topic::IncludeParam>),
			Fetch(topic::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Topics(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("topics");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: topic::ManyArgs,
				nested_selections: Vec<topic::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod url {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UrlEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Url(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Url(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUrl(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Url(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Url(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("url").build()
			}
		}
	}
	pub mod source {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<source::WhereParam>) -> WhereParam {
			WhereParam::SourceIs(value)
		}
		pub fn is_not(value: Vec<source::WhereParam>) -> WhereParam {
			WhereParam::SourceIsNot(value)
		}
		pub struct Fetch(pub source::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<source::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Source(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(source::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: source::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub struct Connect(source::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectSource(value.0)
			}
		}
		pub enum Include {
			Select(Vec<source::SelectParam>),
			Include(Vec<source::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Source(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("source");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<source::SelectParam>),
			Include(Vec<source::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Source(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("source");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod source_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::SourceIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::SourceId(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::NotInVec(value))
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Lt(value))
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Lte(value))
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Gt(value))
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Gte(value))
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::SourceId(_prisma::read_filters::IntFilter::Not(value))
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementSourceId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementSourceId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplySourceId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideSourceId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetSourceId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SourceId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sourceId").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SourceId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("sourceId").build()
			}
		}
	}
	pub fn create(
		title: String,
		url: String,
		source: super::source::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> (
		String,
		String,
		super::source::UniqueWhereParam,
		Vec<SetParam>,
	) {
		(title, url, source, _params)
	}
	pub fn create_unchecked(
		title: String,
		url: String,
		source_id: i32,
		_params: Vec<SetParam>,
	) -> (String, String, i32, Vec<SetParam>) {
		(title, url, source_id, _params)
	}
	#[macro_export]
	macro_rules ! _select_category { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: category :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: category :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: category :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: category :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: category :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: category :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , title , topics , url , source , source_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: category :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: category :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: category :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: category :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: category :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: category :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "topics" , "url" , "source" , "sourceId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: category :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: category :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; topics : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < topics :: Data > } ; (@ field_type ; topics) => { Vec < crate :: prisma :: topic :: Data > } ; (@ field_type ; url) => { String } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; source_id) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Category" , available fields are "id, title, topics, url, source, source_id")) } ; (@ field_module ; topics : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: topic :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: source :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: title :: Select) } ; (@ selection_field_to_selection_param ; topics $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: topics :: Select :: $ selection_mode ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: topic :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; topics $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: topics :: Select :: Fetch ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: url :: Select) } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: source :: Select :: $ selection_mode ($ crate :: prisma :: source :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: source :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < $ crate :: prisma :: category :: SelectParam > :: into ($ crate :: prisma :: category :: source_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: category :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; topics) => { "topics" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; source_id) => { "sourceId" } ; }
	pub use _select_category as select;
	pub enum SelectParam {
		Id(id::Select),
		Title(title::Select),
		Topics(topics::Select),
		Url(url::Select),
		Source(source::Select),
		SourceId(source_id::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Topics(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Source(data) => data.to_selection(),
				Self::SourceId(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_category { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: category :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: category :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: category :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: category :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: category :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: category :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: category :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { topics , source } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub title : String , pub url : String , pub source_id : i32 , $ (pub $ field : $ crate :: prisma :: category :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (title) , stringify ! (url) , stringify ! (source_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; title) , & self . title) ? ; state . serialize_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; source_id) , & self . source_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , title , url , source_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: category :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: category :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: category :: include ! (@ field_serde_name ; title) , ", " , $ crate :: prisma :: category :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: category :: include ! (@ field_serde_name ; source_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: category :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: category :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: category :: include ! (@ field_serde_name ; title) => Ok (Field :: title) , $ crate :: prisma :: category :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: category :: include ! (@ field_serde_name ; source_id) => Ok (Field :: source_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut title = None ; let mut url = None ; let mut source_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; title))) ; } title = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; source_id))) ; } source_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; id))) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; title))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; url))) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: category :: include ! (@ field_serde_name ; source_id))) ? ; Ok (Data { id , title , url , source_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "topics" , "url" , "source" , "sourceId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (title) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (url) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (source_id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: category :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: category :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; topics : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < topics :: Data > } ; (@ field_type ; topics) => { Vec < crate :: prisma :: topic :: Data > } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Category" , available relations are "topics, source")) } ; (@ field_module ; topics : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: topic :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: source :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; topics $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: category :: IncludeParam > :: into ($ crate :: prisma :: category :: topics :: Include :: $ selection_mode ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: topic :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; topics $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: category :: IncludeParam > :: into ($ crate :: prisma :: category :: topics :: Include :: Fetch ($ crate :: prisma :: topic :: ManyArgs :: new ($ crate :: prisma :: topic :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: category :: IncludeParam > :: into ($ crate :: prisma :: category :: source :: Include :: $ selection_mode ($ crate :: prisma :: source :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: category :: IncludeParam > :: into ($ crate :: prisma :: category :: source :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: category :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; topics) => { "topics" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; source_id) => { "sourceId" } ; }
	pub use _include_category as include;
	pub enum IncludeParam {
		Id(id::Include),
		Title(title::Include),
		Topics(topics::Include),
		Url(url::Include),
		Source(source::Include),
		SourceId(source_id::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Title(data) => data.to_selection(),
				Self::Topics(data) => data.to_selection(),
				Self::Url(data) => data.to_selection(),
				Self::Source(data) => data.to_selection(),
				Self::SourceId(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(
		rename = "Category",
		crate = "prisma_client_rust::rspc::internal::specta"
	)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "title")]
		pub title: String,
		#[serde(rename = "topics")]
		#[specta(skip)]
		pub topics: Option<Vec<super::topic::Data>>,
		#[serde(rename = "url")]
		pub url: String,
		#[serde(rename = "source")]
		#[specta(skip)]
		pub source: Option<Box<super::source::Data>>,
		#[serde(rename = "sourceId")]
		pub source_id: i32,
	}
	impl Data {
		pub fn topics(
			&self,
		) -> Result<&Vec<super::topic::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.topics
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(topics),
				))
		}
		pub fn source(
			&self,
		) -> Result<&super::source::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.source
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(source),
				))
				.map(|v| v.as_ref())
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Topics(super::topic::ManyArgs),
		Source(super::source::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Topics(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: topic :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("topics");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
				Self::Source(args) => {
					let mut selections = < super :: source :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("source");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetTitle(String),
		ConnectTopics(Vec<super::topic::UniqueWhereParam>),
		DisconnectTopics(Vec<super::topic::UniqueWhereParam>),
		SetTopics(Vec<super::topic::UniqueWhereParam>),
		SetUrl(String),
		ConnectSource(super::source::UniqueWhereParam),
		SetSourceId(i32),
		IncrementSourceId(i32),
		DecrementSourceId(i32),
		MultiplySourceId(i32),
		DivideSourceId(i32),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetTitle(value) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectTopics(where_params) => (
					"topics".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::topic::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectTopics(where_params) => (
					"topics".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::topic::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetTopics(where_params) => (
					"topics".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::topic::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetUrl(value) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectSource(where_param) => (
					"source".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::source::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::SetSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplySourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideSourceId(value) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Title(::prisma_client_rust::Direction),
		Url(::prisma_client_rust::Direction),
		SourceId(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Title(direction) => (
					"title".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Url(direction) => (
					"url".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::SourceId(direction) => (
					"sourceId".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		Id(_prisma::read_filters::IntFilter),
		TitleEquals(String),
		Title(_prisma::read_filters::StringFilter),
		TopicsSome(Vec<super::topic::WhereParam>),
		TopicsEvery(Vec<super::topic::WhereParam>),
		TopicsNone(Vec<super::topic::WhereParam>),
		UrlEquals(String),
		Url(_prisma::read_filters::StringFilter),
		SourceIs(Vec<super::source::WhereParam>),
		SourceIsNot(Vec<super::source::WhereParam>),
		SourceIdEquals(i32),
		SourceId(_prisma::read_filters::IntFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::TitleEquals(value) => (
					"title",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Title(value) => ("title", value.into()),
				Self::TopicsSome(where_params) => (
					"topics",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TopicsEvery(where_params) => (
					"topics",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TopicsNone(where_params) => (
					"topics",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::UrlEquals(value) => (
					"url",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Url(value) => ("url", value.into()),
				Self::SourceIs(where_params) => (
					"source",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SourceIsNot(where_params) => (
					"source",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SourceIdEquals(value) => (
					"sourceId",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::SourceId(value) => ("sourceId", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UrlEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UrlEquals(value) => Self::UrlEquals(value),
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Category";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "title", "url", "sourceId"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(
			self,
			title: String,
			url: String,
			source: super::source::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> Create<'a> {
			_params.push(title::set(title));
			_params.push(url::set(url));
			_params.push(source::connect(source));
			Create::new(self.client, _params)
		}
		pub fn create_many(
			self,
			data: Vec<(String, String, i32, Vec<SetParam>)>,
		) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(title, url, source_id, mut _params)| {
					_params.push(title::set(title));
					_params.push(url::set(url));
					_params.push(source_id::set(source_id));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(title, url, source, mut _params): (
				String,
				String,
				super::source::UniqueWhereParam,
				Vec<SetParam>,
			),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(title::set(title));
			_params.push(url::set(url));
			_params.push(source::connect(source));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClientBuilder {
		url: Option<String>,
		action_notifier: ::prisma_client_rust::ActionNotifier,
	}
	impl PrismaClientBuilder {
		pub fn new() -> Self {
			Self {
				url: None,
				action_notifier: ::prisma_client_rust::ActionNotifier::new(),
			}
		}
		pub fn with_url(mut self, url: String) -> Self {
			self.url = Some(url);
			self
		}
		pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
			let config =
				::prisma_client_rust::datamodel::parse_configuration(super::DATAMODEL_STR)?.subject;
			let source = config
				.datasources
				.first()
				.expect("Please supply a datasource in your schema.prisma file");
			let url = match self.url {
				Some(url) => url,
				None => {
					let url = if let Some(url) = source.load_shadow_database_url()? {
						url
					} else {
						source.load_url(|key| std::env::var(key).ok())?
					};
					match url.starts_with("file:") {
						true => {
							let path = url.split(":").nth(1).unwrap();
							if std::path::Path::new("./prisma/schema.prisma").exists() {
								format!("file:./prisma/{}", path)
							} else {
								url
							}
						}
						_ => url,
					}
				}
			};
			let (db_name, executor) =
				::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
			let internal_model =
				::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(
					super::DATAMODEL_STR,
				)
				.build(db_name);
			let query_schema =
				std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
					internal_model,
					true,
					source.capabilities(),
					vec![],
					source.referential_integrity(),
				));
			executor.primary_connector().get_connection().await?;
			Ok(PrismaClient(::prisma_client_rust::PrismaClientInternals {
				executor,
				query_schema,
				url,
				action_notifier: self.action_notifier,
			}))
		}
	}
	pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub fn _builder() -> PrismaClientBuilder {
			PrismaClientBuilder::new()
		}
		pub fn _query_raw<T: serde::de::DeserializeOwned>(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::Result<T::ReturnType> {
			::prisma_client_rust::batch(queries, &self.0).await
		}
		pub async fn _migrate_deploy(
			&self,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
			let res = ::prisma_client_rust::migrations::migrate_deploy(
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url,
			)
			.await;
			::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
			res
		}
		pub async fn _migrate_resolve(
			&self,
			migration: &str,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
			::prisma_client_rust::migrations::migrate_resolve(
				migration,
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url,
			)
			.await
		}
		pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
			::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url)
		}
		pub fn topic(&self) -> super::topic::Actions {
			super::topic::Actions { client: &self.0 }
		}
		pub fn source(&self) -> super::source::Actions {
			super::source::Actions { client: &self.0 }
		}
		pub fn issue(&self) -> super::issue::Actions {
			super::issue::Actions { client: &self.0 }
		}
		pub fn issue_item(&self) -> super::issue_item::Actions {
			super::issue_item::Actions { client: &self.0 }
		}
		pub fn category(&self) -> super::category::Actions {
			super::category::Actions { client: &self.0 }
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum CategoryScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "title")]
		Title,
		#[serde(rename = "url")]
		Url,
		#[serde(rename = "sourceId")]
		SourceId,
	}
	impl ToString for CategoryScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Title => "title".to_string(),
				Self::Url => "url".to_string(),
				Self::SourceId => "sourceId".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum IssueItemScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "url")]
		Url,
		#[serde(rename = "issueId")]
		IssueId,
	}
	impl ToString for IssueItemScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Url => "url".to_string(),
				Self::IssueId => "issueId".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum IssueScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "url")]
		Url,
		#[serde(rename = "title")]
		Title,
		#[serde(rename = "topicId")]
		TopicId,
	}
	impl ToString for IssueScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Url => "url".to_string(),
				Self::Title => "title".to_string(),
				Self::TopicId => "topicId".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum SourceScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "title")]
		Title,
		#[serde(rename = "url")]
		Url,
		#[serde(rename = "lang")]
		Lang,
	}
	impl ToString for SourceScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Title => "title".to_string(),
				Self::Url => "url".to_string(),
				Self::Lang => "lang".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum TopicScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "title")]
		Title,
		#[serde(rename = "description")]
		Description,
		#[serde(rename = "url")]
		Url,
		#[serde(rename = "sourceId")]
		SourceId,
		#[serde(rename = "cover")]
		Cover,
	}
	impl ToString for TopicScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Title => "title".to_string(),
				Self::Description => "description".to_string(),
				Self::Url => "url".to_string(),
				Self::SourceId => "sourceId".to_string(),
				Self::Cover => "cover".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	pub mod read_filters {
		use super::*;
		#[derive(Clone)]
		pub enum IntFilter {
			InVec(Vec<i32>),
			NotInVec(Vec<i32>),
			Lt(i32),
			Lte(i32),
			Gt(i32),
			Gte(i32),
			Not(i32),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum StringFilter {
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Not(String),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				}
			}
		}
	}
}
pub use _prisma::PrismaClient;
